<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Assembly Language Programming</title>
  <link href="https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css" rel="stylesheet" />
  <link rel="stylesheet" href="../../assets/css/page-style.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css"
    integrity="sha512-...your-integrity-hash...=" crossorigin="anonymous" />
  <link rel="icon" href="../../assets/images/favicon.png" type="image/x-icon" />
  <link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />




  <style>
    .loader {
      position: absolute;
      top: 50%;
      left: 50%;
      -webkit-transform: translate(-50%, -50%);
      transform: translate(-50%, -50%);
      width: 50px;
      height: 10px;
      background: #e56707;
      border-radius: 5px;
      -webkit-animation: load 1.8s ease-in-out infinite;
      animation: load 1.8s ease-in-out infinite;
    }

    .loader:before,
    .loader:after {
      position: absolute;
      display: block;
      content: "";
      -webkit-animation: load 1.8s ease-in-out infinite;
      animation: load 1.8s ease-in-out infinite;
      height: 10px;
      border-radius: 5px;
    }

    .loader:before {
      top: -20px;
      left: 10px;
      width: 40px;
      background: #c87405;
    }

    .loader:after {
      bottom: -20px;
      width: 35px;
      background: #F5AB35;
    }

    @-webkit-keyframes load {
      0% {
        -webkit-transform: translateX(40px);
        transform: translateX(40px);
      }

      50% {
        -webkit-transform: translateX(-30px);
        transform: translateX(-30px);
      }

      100% {
        -webkit-transform: translateX(40px);
        transform: translateX(40px);
      }
    }

    @keyframes load {
      0% {
        -webkit-transform: translateX(40px);
        transform: translateX(40px);
      }

      50% {
        -webkit-transform: translateX(-30px);
        transform: translateX(-30px);
      }

      100% {
        -webkit-transform: translateX(40px);
        transform: translateX(40px);
      }
    }



    .get {
      margin-top: 350px !important;

    }

    .menu-link:hover .fas {
      color: #f5ede6;
      transform: translateX(-50%);
      transition: transform 500ms ease-in-out;
    }



    h1 {
      text-align: center;
    }

    .uli {
      --col-gap: 1.2rem;
      --row-gap: 1.6rem;
      --line-w: 0.25rem;
      display: grid;
      grid-template-columns: var(--line-w) 1fr;
      grid-auto-columns: max-content;
      column-gap: var(--col-gap);
      list-style: none;
      width: min(60rem, 90%);
      margin-inline: auto;
    }

    /* line */
    .uli::before {
      content: "";
      grid-column: 1;
      grid-row: 1 / span 20;
      background: rgb(225, 225, 225);
      border-radius: calc(var(--line-w) / 2);
    }

    /* columns*/

    /* row gaps */
    .uli li:not(:last-child) {
      margin-bottom: var(--row-gap);
    }

    /* card */
    .uli li {
      grid-column: 2;
      --inlineP: 1.5rem;
      margin-inline: var(--inlineP);
      grid-row: span 2;
      display: grid;
      grid-template-rows: min-content min-content min-content;
    }

    /* date */
    .uli li .date {
      --dateH: 3rem;
      height: var(--dateH);
      margin-inline: calc(var(--inlineP) * -1);

      text-align: center;
      background-color: var(--accent-color);

      color: white;
      font-size: 1.0rem;
      font-weight: 700;

      display: grid;
      place-content: center;
      position: relative;

      border-radius: calc(var(--dateH) / 2) 0 0 calc(var(--dateH) / 2);
    }

    /* date flap */
    .uli li .date::before {
      content: "";
      width: var(--inlineP);
      aspect-ratio: 1;
      background: var(--accent-color);
      background-image: linear-gradient(rgba(0, 0, 0, 0.2) 100%, transparent);
      position: absolute;
      top: 100%;

      clip-path: polygon(0 0, 100% 0, 0 100%);
      right: 0;
    }

    /* circle */
    .uli li .date::after {
      content: "";
      position: absolute;
      width: 1.5rem;
      aspect-ratio: 1;
      background: var(--bgColor);
      border: 0.3rem solid var(--accent-color);
      border-radius: 50%;
      top: 50%;

      transform: translate(50%, -50%);
      right: calc(100% + var(--col-gap) + var(--line-w) / 2);
    }

    /* title descr */
    .uli li .title,
    .uli li .descr {
      background: var(--bgColor);
      position: relative;
      padding-inline: 1rem;
    }

    .uli li .title {
      overflow: hidden;
      padding-block-start: 1.5rem;
      padding-block-end: 1rem;
      font-weight: 600;
      color: #76562b;
    }

    .uli li .descr {
      padding-block-end: 0.7rem;
      font-weight: 500;
      font-size: 14px;
      color: #382409;

    }

    /* shadows */
    .uli li .title::before,
    .uli li .descr::before {
      content: "";
      position: absolute;
      width: 90%;
      height: 0.3rem;
      background: rgba(139, 69, 19, 0.2);
      left: 50%;
      border-radius: 50%;
      filter: blur(4px);
      transform: translate(-50%, 50%);
    }

    .uli li .title::before {
      bottom: calc(100% + 0.125rem);
    }

    .uli li .descr::before {
      z-index: -1;
      bottom: 0.25rem;
    }

    @media (min-width: 40rem) {
      .uli {
        grid-template-columns: 1fr var(--line-w) 1fr;
      }

      .uli::before {
        grid-column: 2;
      }

      .uli li:nth-child(odd) {
        grid-column: 1;
      }

      .uli li:nth-child(even) {
        grid-column: 3;
      }

      /* start second card */
      .uli li:nth-child(2) {
        grid-row: 2/4;
      }

      .uli li:nth-child(odd) .date::before {
        clip-path: polygon(0 0, 100% 0, 100% 100%);
        left: 0;
      }

      .uli li:nth-child(odd) .date::after {
        transform: translate(-50%, -50%);
        left: calc(100% + var(--col-gap) + var(--line-w) / 2);
      }

      .uli li:nth-child(odd) .date {
        border-radius: 0 calc(var(--dateH) / 2) calc(var(--dateH) / 2) 0;
      }
    }













    /* THEMES */

    /********** Theme: dark **********/
    /* Font styles */

    /* Rotor group headings */
    .flipdown.flipdown__theme-dark .rotor-group-heading:before {
      color: #008080;
      font-weight: bold;
      margin-bottom: 10px;

    }

    /* Delimeters */
    .flipdown.flipdown__theme-dark .rotor-group:nth-child(n+2):nth-child(-n+3):before,
    .flipdown.flipdown__theme-dark .rotor-group:nth-child(n+2):nth-child(-n+3):after {
      background-color: #869393;
    }

    /* Rotor tops */
    .flipdown.flipdown__theme-dark .rotor,
    .flipdown.flipdown__theme-dark .rotor-top,
    .flipdown.flipdown__theme-dark .rotor-leaf-front {
      color: #FFFFFF;
      font-weight: bold;
      font-size: 28px;
      background-color: #008080;
    }

    /* Rotor bottoms */
    .flipdown.flipdown__theme-dark .rotor-bottom,
    .flipdown.flipdown__theme-dark .rotor-leaf-rear {
      color: #FFFFFF;
      font-weight: bold;
      font-size: 28px;
      background-color: #008080;
    }

    /* Hinge */
    .flipdown.flipdown__theme-dark .rotor:after {
      border-top: solid 0.1px#a2b3b3;
    }


    /* END OF THEMES */

    .flipdown {
      overflow: visible;
      width: 510px;
      height: 110px;
    }

    .flipdown .rotor-group {
      position: relative;
      float: left;
      padding-right: 30px;
    }

    .flipdown .rotor-group:last-child {
      padding-right: 0;
    }

    .flipdown .rotor-group-heading:before {
      display: block;
      height: 30px;
      line-height: 30px;
      text-align: center;
    }

    .flipdown .rotor-group:nth-child(1) .rotor-group-heading:before {
      content: attr(data-before);
    }

    .flipdown .rotor-group:nth-child(2) .rotor-group-heading:before {
      content: attr(data-before);
    }

    .flipdown .rotor-group:nth-child(3) .rotor-group-heading:before {
      content: attr(data-before);
    }

    .flipdown .rotor-group:nth-child(4) .rotor-group-heading:before {
      content: attr(data-before);
    }

    .flipdown .rotor-group:nth-child(n+2):nth-child(-n+3):before {
      content: '';
      position: absolute;
      bottom: 20px;
      left: 115px;
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }

    .flipdown .rotor-group:nth-child(n+2):nth-child(-n+3):after {
      content: '';
      position: absolute;
      bottom: 50px;
      left: 115px;
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }

    .flipdown .rotor {
      position: relative;
      float: left;
      width: 50px;
      height: 80px;
      margin: 0px 5px 0px 0px;
      border-radius: 4px;
      font-size: 4rem;
      text-align: center;
      perspective: 200px;
    }

    .flipdown .rotor:last-child {
      margin-right: 0;
    }

    .flipdown .rotor-top,
    .flipdown .rotor-bottom {
      overflow: hidden;
      position: absolute;
      width: 50px;
      height: 40px;
    }

    .flipdown .rotor-leaf {
      z-index: 1;
      position: absolute;
      width: 50px;
      height: 80px;
      transform-style: preserve-3d;
      transition: transform 0s;
    }

    .flipdown .rotor-leaf.flipped {
      transform: rotateX(-180deg);
      transition: all 0.5s ease-in-out;
    }

    .flipdown .rotor-leaf-front,
    .flipdown .rotor-leaf-rear {
      overflow: hidden;
      position: absolute;
      width: 50px;
      height: 40px;
      margin: 0;
      transform: rotateX(0deg);
      backface-visibility: hidden;
      -webkit-backface-visibility: hidden;
    }

    .flipdown .rotor-leaf-front {
      line-height: 80px;
      border-radius: 4px 4px 0px 0px;
    }

    .flipdown .rotor-leaf-rear {
      line-height: 0px;
      border-radius: 0px 0px 4px 4px;
      transform: rotateX(-180deg);
    }

    .flipdown .rotor-top {
      line-height: 80px;
      border-radius: 4px 4px 0px 0px;
    }

    .flipdown .rotor-bottom {
      bottom: 0;
      line-height: 0px;
      border-radius: 0px 0px 4px 4px;
    }

    .flipdown .rotor:after {
      content: '';
      z-index: 2;
      position: absolute;
      bottom: 0px;
      left: 0px;
      width: 50px;
      height: 40px;
      border-radius: 0px 0px 4px 4px;
    }

    @media (max-width: 330px) and (min-width: 0px) {
      .flipdown {
        width: 280px !important;
        height: 140px !important;
        display: flex;
        flex-wrap: wrap;
        overflow-x: scroll !important;

        margin-left: -5px !important;

      }
    }

    @media (max-width: 550px) {

      .flipdown {
        width: 312px;
        height: 70px;

      }

      .flipdown .rotor {
        font-size: 2.2rem;
        margin-right: 3px;
      }

      .flipdown .rotor,
      .flipdown .rotor-leaf,
      .flipdown .rotor-leaf-front,
      .flipdown .rotor-leaf-rear,
      .flipdown .rotor-top,
      .flipdown .rotor-bottom,
      .flipdown .rotor:after {
        width: 30px;
      }

      .flipdown .rotor-group {
        padding-right: 20px;
      }

      .flipdown .rotor-group:last-child {
        padding-right: 0px;
      }

      .flipdown .rotor-group-heading:before {
        font-size: 0.8rem;
        height: 20px;
        line-height: 20px;
      }

      .flipdown .rotor-group:nth-child(n+2):nth-child(-n+3):before,
      .flipdown .rotor-group:nth-child(n+2):nth-child(-n+3):after {
        left: 69px;
      }

      .flipdown .rotor-group:nth-child(n+2):nth-child(-n+3):before {
        bottom: 13px;
        height: 8px;
        width: 8px;
      }

      .flipdown .rotor-group:nth-child(n+2):nth-child(-n+3):after {
        bottom: 29px;
        height: 8px;
        width: 8px;
      }

      .flipdown .rotor-leaf-front,
      .flipdown .rotor-top {
        line-height: 50px;
      }

      .flipdown .rotor-leaf,
      .flipdown .rotor {
        height: 50px;
      }

      .flipdown .rotor-leaf-front,
      .flipdown .rotor-leaf-rear,
      .flipdown .rotor-top,
      .flipdown .rotor-bottom,
      .flipdown .rotor:after {
        height: 25px;
      }
    }




















    .example h1,
    .example p,
    .example .button {
      transition: all 0.2s ease-in-out;
    }

    .example {

      height: 300px;


      padding: 20px;
      box-sizing: border-box;
      background-color: #f5ede6;

    }

    .example .flipdown {
      margin: auto;

    }

    .example h3 {
      text-align: center;
      font-weight: 700;
      font-size: 1.5em;
      margin-top: 0;
      margin-bottom: 20px;
      color: #616b6b;
    }

    .example p {
      text-align: center;
      font-weight: 500;
      margin-top: 0;
      margin-bottom: 40px;
      color: #585757;
      font-size: 15px;

    }

    .example .buttons {
      width: 100%;
      height: 50px;

      display: flex;

      align-items: center;

    }

    .example .buttons p {
      height: 50px;
      line-height: 50px;
      font-weight: 400;
      padding: 0px 25px 0px 0px;
      color: #333;
      margin: 0px;
    }

    .example .button {
      display: inline-block;
      height: 50px;

      line-height: 46px;
      text-decoration: none;
      color: #333;
      padding: 0px 20px;
      border: solid 2px #333;
      border-radius: 4px;
      text-transform: uppercase;
      font-weight: 700;
      transition: all 0.2s ease-in-out;
    }

    .example .button:hover {
      background-color: #333;
      color: #fff;
    }

    .example .button i {
      margin-right: 5px;
    }

    @media (max-width: 550px) {
      .example {
        width: 100%;
        height: 362px;
      }

      .example h1 {
        font-size: 2.5em;
      }

      .example p {
        margin-bottom: 25px;
      }

      .example .buttons {
        width: 100%;
        margin-top: 25px;
        text-align: center;
        display: flex;
        flex-direction: column;
      }

      .example .buttons p,
      .example .buttons a {
        float: none;
        margin: 0 auto;
      }

      .example .buttons p {
        padding-right: 0px;
      }

      .example .buttons a {
        display: inline-block;
      }
    }
  </style>
</head>

<body>


  <nav class="navbar">



    <div class="container">

      <h2 class="sem2" style="font-size: 17px;">INTE 223 Revision</h2>

      <div class="menu">

        <a class="menu-link" onclick="goBack()" style="color: #412f22; cursor:pointer;"><i style="font-size: 14px;"
            class="fas fa-arrow-left"></i> Go Back</a>

        <script>
          function goBack() {
            window.history.back();
          }
        </script>



      </div>

      <button class="hamburger" onclick="toggleHamburger()">
        <span></span>
        <span></span>
        <span></span>
      </button>

    </div>

  </nav>






  <div id="timetablePopup" style=" margin-bottom:100px; margin-top:100px;">


    <div class="example" style="text-align: center;">
      <h3>Countdown To INTE 223 exam</h3>

      <div id="flipdown" class="flipdown" style="display: flex; flex-wrap:wrap; flex-direction:column;"></div>
    </div>


    <div class="timeline">
      <h1 data-aos="fade-down" data-aos-delay="100"
        style="font-size: 1.4rem; margin-top: -50px; margin-bottom:40px;   font-family: 'Signika', sans-serif;font-weight:bold; color: rgb(106, 74, 34); ">
        Assembly Language Programming</h1>
      <ul class="uli">
        <li style="--accent-color:#3D1F00" data-aos="fade-up" data-aos-delay="100">
          <div class="date">Terminologies</div>

          <div class="descr" style="margin-top:30px;margin-bottom: -8px; font-size:16px;">
            <strong style="font-weight: bold;">Bit:</strong> The smallest unit of data in assembly language programming,
            representing 0 or 1.
            <br><br>
            <strong style="font-weight: bold;">Byte:</strong> A group of 8 bits, used to store small data values like
            characters or
            numbers in assembly language.
            <br><br>
            <strong style="font-weight: bold;">Word:</strong> The size of data a microprocessor can handle in a single
            operation,
            such as 16 bits.
            <br><br>
            <strong style="font-weight: bold;">Double Word:</strong> A data size that is twice as large as a word, often
            32 bits in
            assembly language.
            <br><br>
            <strong style="font-weight: bold;">Bandwidth:</strong> The data transfer capacity, measured in bits per
            second (bps) or
            bytes per second (Bps), indicating how much data can be moved in a given time.
            <br><br>
            <strong style="font-weight: bold;">Clockspeed:</strong> Number of instructions per second measured in Hertz
            (Hz).


          </div>

        </li>




        <li style="--accent-color: #6D4C00" data-aos="fade-up" data-aos-delay="100">
          <div class="date"> Assembly Language
          </div>

          <div class="descr" style="margin-top:30px;margin-bottom: -8px; font-size:16px;">


            <strong style="font-weight: bold;">In assembly language, you must use the initial letter (radix) to indicate
              the number
              system of a value. For example:</strong> <br>

            • 1011B is binary 1011<br>
            • 27O is octal 27<br>
            • 127DH is hexadecimal 127D<br>
            • If you don't specify the initial letter, the assembler assumes it's a decimal number. <br> <br>

            <strong style="font-weight: bold;">Levels of Programming Languages:</strong> <br>

            • Machine Language: Individual CPU instructions executed one by one.<br>
            • Assembly Language: Processor-specific symbolic instructions assembled into machine language.<br>
            • High-Level Languages (e.g., C, C++): Eliminate computer technicalities, compile to many low-level
            instructions. <br> <br>

            <strong style="font-weight: bold;">Assembly language:</strong> Low-level language for direct communication
            with computer
            hardware. Readable by humans, uses symbols instead of binary/hexadecimal.

            <br> <br>
            <strong style="font-weight: bold;">Assembler program:</strong> Translates mnemonics and syntax for
            operations and
            addressing modes into numerical object code.

            <br><br>

            <strong style="font-weight: bold;">Advantages of Assembly Language Programming (ALP):</strong>
            <br>

            • Minimal Bloat: ALP results in smaller executable sizes, saving memory and storage space.<br>
            • Minimal Overhead: It offers lower-level control, reducing unnecessary operations and improving
            efficiency.<br>
            • Greater Speed: ALP can lead to faster execution due to its direct interaction with hardware.<br>
            • Reliability: By directly controlling hardware, ALP can enhance stability and predictability.
            <br> <br>

            <strong style="font-weight: bold;">ALP is especially useful in the following scenarios:</strong> <br>

            • Limited High-Level Language Options: For older processors with few high-level language choices.<br>
            • Direct Hardware Interaction: Required for device drivers or when dealing with specific hardware
            features.<br>
            • Processor-Specific Instructions: When certain processor instructions are not available in compilers.<br>
            • Cryptographic Algorithms: For consistent execution times to prevent timing attacks.<br>
            • Full Environment Control: In extremely high-security situations where complete control is essential.<br>
            • No High-Level Language: When no suitable high-level language exists for a specific system.

            <br><br>

            <strong style="font-weight: bold;">Low-Level Programming Languages:</strong><br><br>
            • Platform Dependencies: Platform-dependent, can only run on hardware with the same configuration.<br>
            • Speed: Faster due to fewer syntaxes and direct execution without conversions.<br>
            • Easiness: Less user-friendly, written in binary or assembly with complex mnemonics.<br>
            • Performance: Better performance due to faster execution.<br>
            • Translation: Binary doesn't need translation, assembly requires an assembler.<br><br>

            <strong style="font-weight: bold;">High-Level Programming Languages:</strong><br><br>
            • Platform Dependencies: Platform-independent, can run on different hardware configurations.<br>
            • Speed: Slower than low-level languages due to additional abstraction and conversion overhead.<br>
            • Easiness: User-friendly, easier to write, read, modify, and understand.<br>
            • Performance: Lower performance compared to low-level languages.<br>
            • Translation: Translated by compilers or interpreters into object/binary files.


          </div>

        </li>




        <li style="--accent-color: #964B00" data-aos="fade-up" data-aos-delay="100">
          <div class="date">Compilation
          </div>

          <div class="descr" style="margin-top:30px;margin-bottom: -8px; font-size:16px;">


            <strong style="font-weight: bold;">Compiling a Program:</strong><br><br>
            <strong style="font-weight: bold;">Preprocessing:</strong> First pass of C compilation. Processes
            include-files,
            conditional compilation instructions, and macros.<br>
            <strong style="font-weight: bold;">Compilation:</strong> Second pass. Takes preprocessor output and source
            code,
            generating assembler source code.<br>
            <strong style="font-weight: bold;">Assembly:</strong> Third stage of compilation. Takes assembly source
            code, produces
            assembly listing with offsets, and stores it in an object file.<br>
            <strong style="font-weight: bold;">Linking:</strong> Final stage. Takes one or more object files or
            libraries, combines
            them into a single executable file. Resolves references to external symbols, assigns final addresses, and
            performs
            relocation.<br><br>

            <strong style="font-weight: bold;">Instruction Execution Cycle:</strong><br><br>
            <strong style="font-weight: bold;">IF (Instruction Fetch):</strong> The CPU fetches the next instruction
            from memory and
            loads it into the instruction register.<br>
            <strong style="font-weight: bold;">ID (Instruction Decode):</strong> The fetched instruction is decoded to
            determine the
            operation to be performed and the operands involved.<br>
            <strong style="font-weight: bold;">EX (Execution):</strong> The CPU executes the decoded instruction,
            performing the
            specified operation on the operands.


          </div>

        </li>




        <li style="--accent-color: #964B00" data-aos="fade-up" data-aos-delay="100">
          <div class="date">Microprocessors
          </div>

          <div class="descr" style="margin-top:30px;margin-bottom: -8px; font-size:16px;">

            <strong style="font-weight: bold;">A microprocessor is a central processing unit (CPU) integrated into a
              microchip. <br> It
              executes instructions and performs tasks related to computer processing, serving as the brain of a
              computer or other
              electronic devices.</strong> <br>
            <br>
            <strong style="font-weight: bold;">Three key characteristics of microprocessors:</strong> <br>

            <em>Instruction Set:</em> The set of instructions a microprocessor can perform at the machine level.<br>
            <em>Bandwidth:</em> The number of bits processed in one instruction, affecting RAM access and the
            microprocessor's
            architecture (e.g., 32-bit or 64-bit).<br>
            <em>Clock Speed:</em> Measured in megahertz (MHz), determines how many instructions per second the processor
            can
            execute. Most modern microprocessors operate at around 3 GHz, using multiple processors in parallel to
            overcome
            heat-related limitations.

          </div>

        </li>








        <li style="--accent-color: #964B00" data-aos="fade-up" data-aos-delay="100">
          <div class="date">8086 Microprocessor
          </div>

          <div class="descr" style="margin-top:30px;margin-bottom: -8px; font-size:16px;">

            <strong style="font-weight: bold;">Characteristics </strong><br><br>
            <strong style="font-weight: bold;">- 16-bit microprocessor.</strong><br>
            <strong style="font-weight: bold;">- 20-bit address bus, allowing access to up to 1 MB of
              memory.</strong><br>
            <strong style="font-weight: bold;">- Supports up to 64K input/output (I/O) ports.</strong><br>
            <strong style="font-weight: bold;">- Provides 14, 16-bit registers.</strong><br>
            <strong style="font-weight: bold;">- Features a multiplexed address and data bus (AD0-AD15 and
              A16-A19).</strong><br>
            <strong style="font-weight: bold;">- Can prefetch up to 6 instruction bytes to speed up
              execution.</strong><br>
            <strong style="font-weight: bold;">- Comes in a 40-pin dual in-line package.</strong><br><br>

            <strong style="font-weight: bold;">Registers: High-speed temporary memory in the microprocessor storing
              data. 8086 has
              fourteen 16-bit registers, used for arithmetic, data manipulation, and temporary storage during
              execution.</strong><br><br>

            <strong style="font-weight: bold;">8086 REGISTERS</strong><br><br>
            <em style="font-weight: bold;">General Purpose, or Data Registers:</em><br><br>

            Data registers are high-speed temporary memory locations inside the microprocessor.<br>
            8086 has fourteen 16-bit registers with special uses.<br>
            AX: Accumulator for arithmetic, logic, and data transfer.<br>
            BX: Base Register for addressing.<br>
            CX: Count Register as a loop counter.<br>
            DX: Data Register for multiplication and division.<br>
            Each byte of the 4 data registers can be accessed independently.<br>
            AH, AL, BH, etc., refer to the high and low bytes of the registers (8-bit registers).<br><br>
            <em style="font-weight: bold;">Pointer and Index Registers: SP, BP, SI, DI:</em><br><br>

            SP (Stack Pointer) points to the top of the processor's stack.<br>
            BP (Base Pointer) accesses data on the stack.<br>
            SI (Source Index) points to memory locations in the data segment.<br>
            DI (Destination Index) performs similar functions as SI, often used for string operations.<br><br>
            <strong style="font-weight: bold;">Memory:</strong><br><br>

            8086 supports up to 1 megabyte (2²⁰ bytes) of memory, accessed via 20-bit addresses (00000h to FFFFFh).<br>
            Memory is partitioned into 64K (2¹⁶) segments.<br>
            Each segment is identified by a 16-bit segment number (0000h to FFFFh).<br>
            A 16-bit offset specifies the memory location within a segment.<br><br>
            <em style="font-weight: bold;">Segment:Offset Addresses:</em><br><br>

            Memory is accessed using segment:offset addresses.<br>
            To get the physical address, the segment number is multiplied by 16 and added to the offset.<br>
            Overlapping segments can lead to non-unique addresses.<br>
            Segments are divided into 16-byte paragraphs.<br><br>
            <em style="font-weight: bold;">Segment Registers: CS, DS, SS, ES:</em><br><br>

            CS (Code Segment) holds the start address of the program's machine code.<br>
            DS (Data Segment) addresses the program's data in memory.<br>
            SS (Stack Segment) points to the program's stack space.<br>
            ES (Extra Segment) addresses additional data or special memory operations.<br><br>
            <em style="font-weight: bold;">Instruction and Stack Pointers:</em><br><br>

            IP contains the address of the next instruction to be executed (offset within CS).<br>
            SP points to the top item on the stack (offset within SS).<br><br>
            <em style="font-weight: bold;">BP and Index Registers:</em><br><br>

            BP (Base Pointer) specifies an offset into any segment, commonly used for the Stack segment.<br>
            SI and DI (Index Registers) specify offsets into the Data segment, but they can be used for any
            segment.<br><br>
            <strong style="font-weight: bold;">Flags:</strong><br><br>

            Individual bits store the microprocessor's status.<br>
            Status flags reflect the result of operations, e.g., the Zero Flag (ZF) is set to 1 when the result of an
            arithmetic
            operation is 0.<br>
            Control flags enable or disable certain processor operations, e.g., the Interrupt Flag (IF) controls
            keyboard inputs.

          </div>

        </li>





        <li style="--accent-color: #964B00" data-aos="fade-up" data-aos-delay="100">
          <div class="date">The MOV Instruction
          </div>

          <div class="descr" style="margin-top:30px;margin-bottom: -8px; font-size:16px;">

            <strong style="font-weight: bold;">MOV is a crucial command in 8086 assembly language used to move data
              between memory
              locations or registers.</strong><br><br>
            <strong style="font-weight: bold;">Format:</strong> MOV destination, source<br> <br>
            <strong style="font-weight: bold;">Examples of different operand combinations:</strong><br>
            <em>Register-Register:</em> MOV ax, bx (copies the content of BX register into AX register).<br>
            <em>Register-Immediate:</em> MOV ax, 10h (loads the immediate value 10h into AX register).<br>
            <em>Register-Memory:</em> MOV ax, [bx] (copies the value from the memory location pointed by BX register
            into AX
            register).<br>
            <em>Memory-Immediate:</em> MOV aNumber, 10h (stores the immediate value 10h into a memory location called
            aNumber).<br>
            <em>Memory-Register:</em> MOV aDigit, ax (copies the content of AX register into a memory location called
            aDigit).<br>
            <em>MOV can copy either a byte or a word. The assembler programmer may need to specify the size
              explicitly.</em><br> <br>
            <em style="font-weight: bold;">Some limitations of MOV instruction:</em><br>
            - Immediate value cannot be moved directly into a segment register (e.g., MOV ds, 10 is not allowed).<br>
            - Segment registers cannot be copied directly (e.g., MOV es, ds is not allowed).<br>
            - Memory location cannot be copied into another memory location (e.g., MOV aNumber, aDigit is not
            allowed).<br>
            - CS (Code Segment) cannot be copied to (e.g., MOV cs, ax is not allowed).<br>
            <em>These limitations can be overcome by using indirect data movement through a general-purpose
              register.</em><br><br>

            <strong style="font-weight: bold;">Addressing Modes:</strong><br><br>
            <em>Immediate Addressing:</em><br>
            A constant value is directly moved into a register or memory location.<br>
            Example: mov ax, 10h (loads the immediate value 10h into AX register).<br><br>

            <em>Register Addressing:</em><br>
            A register is used as both the source and destination of the instruction.<br>
            Examples:<br>
            mov ax, bx (copies the content of BX register into AX register).<br>
            mov ax, 10h (loads the immediate value 10h into AX register).<br>
            mov si, es:[bx] (copies the value from the memory location pointed by BX register into SI register).<br><br>

            <em>Direct Memory Addressing:</em><br>
            A memory location is directly accessed using its address as an operand.<br>
            Example: mov ax, aDigit (copies the value from the memory location labeled "aDigit" into AX
            register).<br><br>

            <em>Register Indirect Addressing:</em><br>
            The memory location is specified by a register, which holds the address.<br>
            Example: mov ax, [bx] (copies the value from the memory location pointed by BX register into AX
            register).<br><br>

            <em>Base Relative Addressing:</em><br>
            A combination of direct and indirect addressing, where an offset is added to the value stored in a base
            register.<br>
            Examples:<br>
            mov ax, [bx+4] (accesses the memory location at the address stored in BX register plus an offset of 4).<br>
            mov ax, [bx]+4 (accesses the memory location at the address stored in BX register plus an offset of 4).<br>
            mov ax, 4[bx] (same as the previous example but written differently).<br>
            Only BX and BP registers can be used as base registers.<br><br>

            <em>Base Indexed Addressing:</em><br>
            A combination of a base register and an index register, and an optional offset, are used to calculate the
            effective
            memory address.<br>
            Examples:<br>
            mov ax, [bx+si+4] (accesses the memory location at the address stored in BX plus the address stored in SI,
            plus an
            offset of 4).<br>
            mov ax, [bx][si]+4 (same as the previous example but written differently).<br>
            mov ax, [bx][si+4] (same as the previous example but with an offset).<br>
            Only specific combinations of BX, BP, SI, and DI registers are allowed.<br><br>

            <strong style="font-weight: bold;">Complete Table of Addressing Modes:</strong><br><br>
            - Displacement only<br>
            - BX + displacement<br>
            - BP + displacement<br>
            - SI + displacement<br>
            - DI + displacement<br>
            - BX + SI + displacement<br>
            - BX + DI + displacement<br>
            - BP + SI + displacement<br>
            - BP + DI + displacement<br>

          </div>

        </li>








        <li style="--accent-color: #964B00" data-aos="fade-up" data-aos-delay="100">
          <div class="date">ADD Instruction
          </div>

          <div class="descr" style="margin-top:30px;margin-bottom: -8px; font-size:16px;">

            <strong style="font-weight: bold;">ADD Instruction:</strong><br>
            The ADD instruction is used in assembly language to add two operands, usually numbers, together.<br>
            <strong style="font-weight: bold;">Syntax:</strong> ADD destination, source<br>
            <br>
            <em>Example 1: Add immediate value to a register</em><br>
            MOV AX, 10h ; Load the value 10h into AX register<br>
            ADD AX, 5 ; Add 5 to the value in AX, result will be 15 in AX<br>
            <br>
            <em>Example 2: Add memory value to a register</em><br>
            MOV BX, [aNumber] ; Load the value stored in memory location aNumber into BX register<br>
            ADD BX, 20 ; Add 20 to the value in BX, result will be BX + 20<br>
            <br>
            <em>Example 3: Add two memory values and store the result in another memory location</em><br>
            MOV CX, [val1] ; Load the value from memory location val1 into CX register<br>
            ADD CX, [val2] ; Add the value from memory location val2 to the value in CX<br>
            MOV [result], CX ; Store the result back to the memory location labeled result<br>
            <br>
            <strong style="font-weight: bold;">ADC - Add With Carry:</strong><br>
            <strong style="font-weight: bold;">Syntax:</strong> ADC destination, source<br>
            <br>
            The ADC instruction adds the source operand and the carry flag (CF) to the destination operand.<br>
            <br>
            <em>Example: Add two numbers and the carry flag</em><br>
            MOV AX, 5000 ; Load a value into AX register<br>
            MOV BX, 3000 ; Load another value into BX register<br>
            ADD AX, BX ; Add the value in BX to the value in AX<br>
            ADC AX, 1 ; Add 1 and the carry flag to the result of the previous addition<br>
            ; The carry flag (CF) represents a carry or borrow from a previous operation<br>
            ; Result will be stored in AX register<br>
            <br>
            <strong style="font-weight: bold;">INC - Increment:</strong><br>
            The INC instruction adds 1 to any register or memory location, except a segment register.<br>
            <strong style="font-weight: bold;">Syntax:</strong> INC destination<br>
            <strong style="font-weight: bold;">Effect:</strong> destination → destination + 1<br>
            <strong style="font-weight: bold;">Modifies flags:</strong> AF OF PF SF ZF<br>
            <br>
            This instruction is often used to increment indexes and therefore does not affect the carry flag.

          </div>

        </li>






        <li style="--accent-color: #964B00" data-aos="fade-up" data-aos-delay="100">
          <div class="date">DEC Instruction
          </div>

          <div class="descr" style="margin-top:30px;margin-bottom: -8px; font-size:16px;">

            <strong style="font-weight: bold;">DEC – Decrement subtraction</strong><br>
            Subtracts 1 from a register/memory location.<br>
            <strong style="font-weight: bold;">Syntax:</strong> DEC destination<br>
            <strong style="font-weight: bold;">Effect:</strong> destination → destination – 1<br>
            <strong style="font-weight: bold;">Modifies flags:</strong> AF OF PF SF ZF<br>
            <br>
            This instruction is often used to decrement indexes and therefore does not affect the carry flag.<br><br>

            <strong style="font-weight: bold;">Signed Numbers:</strong><br>
            Signed numbers can be positive, negative, or zero.<br>
            They are represented using a sign bit (usually the leftmost bit) to indicate the sign.<br>
            For example, in a 4-bit signed binary number, the range is from -8 (1000) to +7 (0111).<br><br>

            <strong style="font-weight: bold;">Unsigned Numbers:</strong><br>
            Unsigned numbers are always non-negative and do not have a sign bit.<br>
            They only represent positive values, including zero.<br>
            For example, in a 4-bit unsigned binary number, the range is from 0 (0000) to 15 (1111).

          </div>

        </li>














        <li style="--accent-color: #964B00" data-aos="fade-up" data-aos-delay="100">
          <div class="date">Multiplication & Division
          </div>

          <div class="descr" style="margin-top:30px;margin-bottom: -8px; font-size:16px;">

            <strong style="font-weight: bold;">Multiplication</strong><br>
            Multiplication can be performed on bytes (8 bits) or words (16 bits) and can be either signed (IMUL) or
            unsigned (MUL)
            integer multiplication.<br>
            The product after a multiplication is always a double-width product:<br>

            Two 8-bit numbers multiplied generate a 16-bit product.<br>
            Two 16-bit numbers generate a 32-bit product.<br>
            <br>
            <strong style="font-weight: bold;">SYNTAX:</strong> MUL/IMUL operand<br>
            <br>
            <em>Unsigned multiplication (16-bit)</em><br>
            MOV AX, 10 ; Load AX with multiplicand<br>
            MOV BX, 5 ; Multiplier is implicitly taken from BX<br>
            MUL BX ; AX = AX * BX (result is 50)<br>
            <br>
            <em>Signed multiplication (16-bit)</em><br>
            MOV AX, -10 ; Load AX with signed multiplicand (-10)<br>
            MOV BX, 3 ; Multiplier is implicitly taken from BX<br>
            IMUL BX ; AX = AX * BX (result is -30)<br>
            <br>
            <em>Unsigned multiplication (8-bit)</em><br>
            MOV AL, 10 ; Load AL with multiplicand<br>
            MOV BL, 5 ; Multiplier is taken from BL<br>
            MUL BL ; AX = AL * BL (result is 50)<br>
            <br>
            <em>Signed multiplication (8-bit)</em><br>
            MOV AL, -10 ; Load AL with signed multiplicand (-10)<br>
            MOV BL, 3 ; Multiplier is taken from BL<br>
            IMUL BL ; AX = AL * BL (result is -30)<br>
            <br>
            The DIV and IDIV instructions are used for division:<br>
            <br>
            <em>DIV:</em> It is used for unsigned division, meaning it divides a 16-bit value in the DX:AX register pair
            (combined
            as a 32-bit dividend) by an 8-bit value and stores the quotient in the AX register and the remainder in the
            DX
            register.<br>
            <em>IDIV:</em> It is used for signed division, meaning it divides a 16-bit signed value in the DX:AX
            register pair
            (combined as a 32-bit dividend) by an 8-bit signed value and stores the signed quotient in the AX register
            and the
            signed remainder in the DX register.<br>
            <br>
            <em>Unsigned division (16-bit)</em><br>
            MOV AX, 1000 ; Load AX with dividend (quotient in AX, remainder in DX)<br>
            MOV DX, 0 ; Clear DX for unsigned division<br>
            MOV BL, 10 ; Divisor is taken from BL<br>
            DIV BL ; AX = DX:AX / BL (quotient is 100, remainder is 0)<br>
            <br>
            <em>Signed division (16-bit)</em><br>
            MOV AX, -1000 ; Load AX with signed dividend (quotient in AX, remainder in DX)<br>
            MOV DX, 0 ; Clear DX for signed division<br>
            MOV BL, -5 ; Divisor is taken from BL<br>
            IDIV BL ; AX = DX:AX / BL (quotient is 200, remainder is 0)<br>

          </div>

        </li>












        <li style="--accent-color: #964B00" data-aos="fade-up" data-aos-delay="100">
          <div class="date">Bit Manipulation
          </div>

          <div class="descr" style="margin-top:30px;margin-bottom: -8px; font-size:16px;">

            <strong style="font-weight: bold;">Bit manipulation instructions in 8086:</strong><br>
            Bit manipulation instructions in 8086 are used to perform logical operations on individual bits of data.
            These
            instructions include:<br>
            <br>
            <strong style="font-weight: bold;">NOT:</strong> The NOT instruction inverts each bit of a byte or word. It
            takes the
            destination as an operand and flips all the bits.<br>
            <strong style="font-weight: bold;">AND:</strong> The AND instruction performs a logical AND operation
            between the source
            and destination operands, modifying the destination's bits based on the mask provided in the source.<br>
            <strong style="font-weight: bold;">OR:</strong> The OR instruction performs a logical OR operation between
            the source
            and destination operands, setting specific bits in the destination based on the mask provided in the
            source.<br>
            <strong style="font-weight: bold;">XOR:</strong> The XOR instruction performs a logical XOR operation
            between the source
            and destination operands, toggling specific bits in the destination based on the mask provided in the
            source.<br>
            <strong style="font-weight: bold;">TEST:</strong> The TEST instruction performs a logical AND operation
            between the
            source and destination operands, but it does not modify either operand. Instead, it updates the flags to
            reflect the
            results of the AND operation.<br>
            <br>
            The logical instructions are used to manipulate individual bits in the destination operand while preserving
            other bits
            unchanged. Each bit in the source operand acts as a mask to determine which bits in the destination will be
            modified.<br>
            <br>
            <strong style="font-weight: bold;">Examples:</strong><br>
            <br>
            <em>NOT instruction</em><br>
            NOT AL ; Inverts all bits in AL register<br>
            <br>
            <em>AND instruction</em><br>
            MOV AL, 10101010B ; AL = 0xAA<br>
            AND AL, 11001100B ; AL = AL AND 0xCC (result: 10101000B)<br>
            <br>
            <em>OR instruction</em><br>
            MOV AL, 10101010B ; AL = 0xAA<br>
            OR AL, 00001111B ; AL = AL OR 0x0F (result: 10101111B)<br>
            <br>
            <em>XOR instruction</em><br>
            MOV AL, 10101010B ; AL = 0xAA<br>
            XOR AL, 11110000B ; AL = AL XOR 0xF0 (result: 01011010B)<br>
            <br>
            <em>TEST instruction</em><br>
            MOV AL, 10101010B ; AL = 0xAA<br>
            TEST AL, 00001111B ; AL AND 0x0F (flags updated: ZF=0, PF=0, SF=0, AF=undefined)<br>

          </div>

        </li>




        <li style="--accent-color: #964B00" data-aos="fade-up" data-aos-delay="100">
          <div class="date">Procedures & Macros
          </div>

          <div class="descr" style="margin-top:30px;margin-bottom: -8px; font-size:16px;">

            <strong style="font-weight: bold;">Procedures:</strong><br>
            Procedures are reusable blocks of code that perform specific tasks or functions.<br>
            They are defined with a specific name and can be called from various parts of the program.<br>
            Procedures can take parameters as inputs and return values as outputs.<br>
            When a procedure is called, the program's flow of execution jumps to the procedure's code, and after the
            procedure
            finishes, it returns to the point of the call.<br>
            Procedures are defined using the PROC and ENDP directives in assembly language.<br>
            <br>
            <strong style="font-weight: bold;">Example of a simple procedure to add two numbers:</strong><br>
            <br>
            <code>
            PROC AddNumbers<br>
            &nbsp;&nbsp;&nbsp;&nbsp;MOV AX, [param1]   ; Load first parameter into AX<br>
            &nbsp;&nbsp;&nbsp;&nbsp;ADD AX, [param2]   ; Add second parameter to AX<br>
            &nbsp;&nbsp;&nbsp;&nbsp;RET                ; Return from the procedure, result in AX<br>
            ENDP<br>
            </code>
            <br>
            <strong style="font-weight: bold;">Macros:</strong><br>
            Macros are code templates that allow code expansion at the point of use.<br>
            They are defined using the MACRO and ENDM directives in assembly language.<br>
            Unlike procedures, macros are not separate functions; instead, they are expanded inline at the point where
            they are
            called.<br>
            Macros are useful for short, repetitive code sequences that need to be customized based on the context of
            usage.<br>
            <br>
            <strong style="font-weight: bold;">Example of a simple macro to multiply a value by 2:</strong><br>
            <br>
            <code>
            MULTIPLY_BY_TWO MACRO value<br>
            &nbsp;&nbsp;&nbsp;&nbsp;MOV AX, value   ; Load value into AX<br>
            &nbsp;&nbsp;&nbsp;&nbsp;ADD AX, AX      ; Double the value (multiply by 2)<br>
            ENDM<br>
            </code>
            <br>
            <strong style="font-weight: bold;">Usage of the macro:</strong><br>
            <br>
            <code>
            MOV BX, 5<br>
            MULTIPLY_BY_TWO BX  ; Expands to MOV AX, BX   and   ADD AX, AX<br>
            </code>
            <br>
            <strong style="font-weight: bold;">Procedure:</strong><br>
            A procedure is a block of instructions that is written once but can be executed as needed at any point in a
            program.<br>
            <br>
            <strong style="font-weight: bold;">Levels of Procedures</strong><br>
            <br>
            <strong style="font-weight: bold;">Single Level Procedure:</strong><br>
            A single-level procedure is a simple subroutine called from the main program. It executes a specific task,
            transfers
            control to the procedure, and then returns control to the calling program.<br>
            <br>
            <strong style="font-weight: bold;">Recursive Procedure:</strong><br>
            A recursive procedure calls itself during execution to solve smaller subproblems. It generates nested
            procedure calls,
            making it useful for problems with repetitive substructures.<br>
            <br>
            <strong style="font-weight: bold;">Types of Procedures Based on Addressing</strong><br>
            <br>
            <strong style="font-weight: bold;">Near Procedure:</strong><br>
            A near procedure is located in the same memory segment as the calling program. It offers faster execution
            and is
            suitable for small-scale applications.<br>
            <br>
            <strong style="font-weight: bold;">Far Procedure:</strong><br>
            A far procedure is in a different memory segment from the calling program. It is used for larger
            applications or when
            accessing data beyond segment limitations. Segment override prefix may be required.<br>

          </div>

        </li>




      </ul>
    </div>
  </div>




  <div class="wrapper-loader">







    <div class='loader'></div>


    <p class="get" id="typing-dots">Getting Things Ready</p>

    <script>

      const dotsElement = document.getElementById('typing-dots');
      const dots = '...';
      let dotCount = 0;

      function animateTypingDots() {
        dotsElement.textContent = 'Getting Things Ready' + dots.substring(0, dotCount);
        dotCount = (dotCount + 1) % (dots.length + 1);
        setTimeout(animateTypingDots, 300);
      }

      animateTypingDots();

    </script>








  </div>


  <script>

    document.addEventListener("DOMContentLoaded", () => {
      // Set the target date to August 10th of the current year
      var targetDate = new Date(new Date().getFullYear(), 7, 11, 13, 59).getTime() / 1000; // Month is 0-indexed, so August is represented by 7


      // Set up FlipDown
      var flipdown = new FlipDown(targetDate)

        // Start the countdown
        .start()

        // Do something when the countdown ends
        .ifEnded(() => {
          console.log("The countdown has ended!");
        });



      // Show version number
      var ver = document.getElementById("ver");
      ver.innerHTML = flipdown.version;
    });



























    "use strict";

    function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

    var FlipDown = function () {
      function FlipDown(uts) {
        var el = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "flipdown";
        var opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        _classCallCheck(this, FlipDown);

        if (typeof uts !== "number") {
          throw new Error("FlipDown: Constructor expected unix timestamp, got ".concat(_typeof(uts), " instead."));
        }

        if (_typeof(el) === "object") {
          opt = el;
          el = "flipdown";
        }

        this.version = "0.3.2";
        this.initialised = false;
        this.now = this._getTime();
        this.epoch = uts;
        this.countdownEnded = false;
        this.hasEndedCallback = null;
        this.element = document.getElementById(el);
        this.rotors = [];
        this.rotorLeafFront = [];
        this.rotorLeafRear = [];
        this.rotorTops = [];
        this.rotorBottoms = [];
        this.countdown = null;
        this.daysRemaining = 0;
        this.clockValues = {};
        this.clockStrings = {};
        this.clockValuesAsString = [];
        this.prevClockValuesAsString = [];
        this.opts = this._parseOptions(opt);

        this._setOptions();

        console.log("FlipDown ".concat(this.version, " (Theme: ").concat(this.opts.theme, ")"));
      }

      _createClass(FlipDown, [{
        key: "start",
        value: function start() {
          if (!this.initialised) this._init();
          this.countdown = setInterval(this._tick.bind(this), 1000);
          return this;
        }
      }, {
        key: "ifEnded",
        value: function ifEnded(cb) {
          this.hasEndedCallback = function () {
            cb();
            this.hasEndedCallback = null;
          };

          return this;
        }
      }, {
        key: "_getTime",
        value: function _getTime() {
          return new Date().getTime() / 1000;
        }
      }, {
        key: "_hasCountdownEnded",
        value: function _hasCountdownEnded() {
          if (this.epoch - this.now < 0) {
            this.countdownEnded = true;

            if (this.hasEndedCallback != null) {
              this.hasEndedCallback();
              this.hasEndedCallback = null;
            }

            return true;
          } else {
            this.countdownEnded = false;
            return false;
          }
        }
      }, {
        key: "_parseOptions",
        value: function _parseOptions(opt) {
          var headings = ["Days", "Hours", "Minutes", "Seconds"];

          if (opt.headings && opt.headings.length === 4) {
            headings = opt.headings;
          }

          return {
            theme: opt.hasOwnProperty("theme") ? opt.theme : "dark",
            headings: headings
          };
        }
      }, {
        key: "_setOptions",
        value: function _setOptions() {
          this.element.classList.add("flipdown__theme-".concat(this.opts.theme));
        }
      }, {
        key: "_init",
        value: function _init() {
          this.initialised = true;

          if (this._hasCountdownEnded()) {
            this.daysremaining = 0;
          } else {
            this.daysremaining = Math.floor((this.epoch - this.now) / 86400).toString().length;
          }

          var dayRotorCount = this.daysremaining <= 2 ? 2 : this.daysremaining;

          for (var i = 0; i < dayRotorCount + 6; i++) {
            this.rotors.push(this._createRotor(0));
          }

          var dayRotors = [];

          for (var i = 0; i < dayRotorCount; i++) {
            dayRotors.push(this.rotors[i]);
          }

          this.element.appendChild(this._createRotorGroup(dayRotors, 0));
          var count = dayRotorCount;

          for (var i = 0; i < 3; i++) {
            var otherRotors = [];

            for (var j = 0; j < 2; j++) {
              otherRotors.push(this.rotors[count]);
              count++;
            }

            this.element.appendChild(this._createRotorGroup(otherRotors, i + 1));
          }

          this.rotorLeafFront = Array.prototype.slice.call(this.element.getElementsByClassName("rotor-leaf-front"));
          this.rotorLeafRear = Array.prototype.slice.call(this.element.getElementsByClassName("rotor-leaf-rear"));
          this.rotorTop = Array.prototype.slice.call(this.element.getElementsByClassName("rotor-top"));
          this.rotorBottom = Array.prototype.slice.call(this.element.getElementsByClassName("rotor-bottom"));

          this._tick();

          this._updateClockValues(true);

          return this;
        }
      }, {
        key: "_createRotorGroup",
        value: function _createRotorGroup(rotors, rotorIndex) {
          var rotorGroup = document.createElement("div");
          rotorGroup.className = "rotor-group";
          var dayRotorGroupHeading = document.createElement("div");
          dayRotorGroupHeading.className = "rotor-group-heading";
          dayRotorGroupHeading.setAttribute("data-before", this.opts.headings[rotorIndex]);
          rotorGroup.appendChild(dayRotorGroupHeading);
          appendChildren(rotorGroup, rotors);
          return rotorGroup;
        }
      }, {
        key: "_createRotor",
        value: function _createRotor() {
          var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
          var rotor = document.createElement("div");
          var rotorLeaf = document.createElement("div");
          var rotorLeafRear = document.createElement("figure");
          var rotorLeafFront = document.createElement("figure");
          var rotorTop = document.createElement("div");
          var rotorBottom = document.createElement("div");
          rotor.className = "rotor";
          rotorLeaf.className = "rotor-leaf";
          rotorLeafRear.className = "rotor-leaf-rear";
          rotorLeafFront.className = "rotor-leaf-front";
          rotorTop.className = "rotor-top";
          rotorBottom.className = "rotor-bottom";
          rotorLeafRear.textContent = v;
          rotorTop.textContent = v;
          rotorBottom.textContent = v;
          appendChildren(rotor, [rotorLeaf, rotorTop, rotorBottom]);
          appendChildren(rotorLeaf, [rotorLeafRear, rotorLeafFront]);
          return rotor;
        }
      }, {
        key: "_tick",
        value: function _tick() {
          this.now = this._getTime();
          var diff = this.epoch - this.now <= 0 ? 0 : this.epoch - this.now;
          this.clockValues.d = Math.floor(diff / 86400);
          diff -= this.clockValues.d * 86400;
          this.clockValues.h = Math.floor(diff / 3600);
          diff -= this.clockValues.h * 3600;
          this.clockValues.m = Math.floor(diff / 60);
          diff -= this.clockValues.m * 60;
          this.clockValues.s = Math.floor(diff);

          this._updateClockValues();

          this._hasCountdownEnded();
        }
      }, {
        key: "_updateClockValues",
        value: function _updateClockValues() {
          var _this = this;

          var init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          this.clockStrings.d = pad(this.clockValues.d, 2);
          this.clockStrings.h = pad(this.clockValues.h, 2);
          this.clockStrings.m = pad(this.clockValues.m, 2);
          this.clockStrings.s = pad(this.clockValues.s, 2);
          this.clockValuesAsString = (this.clockStrings.d + this.clockStrings.h + this.clockStrings.m + this.clockStrings.s).split("");
          this.rotorLeafFront.forEach(function (el, i) {
            el.textContent = _this.prevClockValuesAsString[i];
          });
          this.rotorBottom.forEach(function (el, i) {
            el.textContent = _this.prevClockValuesAsString[i];
          });

          function rotorTopFlip() {
            var _this2 = this;

            this.rotorTop.forEach(function (el, i) {
              if (el.textContent != _this2.clockValuesAsString[i]) {
                el.textContent = _this2.clockValuesAsString[i];
              }
            });
          }

          function rotorLeafRearFlip() {
            var _this3 = this;

            this.rotorLeafRear.forEach(function (el, i) {
              if (el.textContent != _this3.clockValuesAsString[i]) {
                el.textContent = _this3.clockValuesAsString[i];
                el.parentElement.classList.add("flipped");
                var flip = setInterval(function () {
                  el.parentElement.classList.remove("flipped");
                  clearInterval(flip);
                }.bind(_this3), 500);
              }
            });
          }

          if (!init) {
            setTimeout(rotorTopFlip.bind(this), 500);
            setTimeout(rotorLeafRearFlip.bind(this), 500);
          } else {
            rotorTopFlip.call(this);
            rotorLeafRearFlip.call(this);
          }

          this.prevClockValuesAsString = this.clockValuesAsString;
        }
      }]);

      return FlipDown;
    }();

    function pad(n, len) {
      n = n.toString();
      return n.length < len ? pad("0" + n, len) : n;
    }

    function appendChildren(parent, children) {
      children.forEach(function (el) {
        parent.appendChild(el);
      });
    }


















  </script>

  <script src="../../assets/js/app.js"></script>
  <script src="../../assets/js/semesters.js"></script>
  <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
  <script>
    AOS.init({
      duration: 700,
    });
  </script>
</body>

</html>